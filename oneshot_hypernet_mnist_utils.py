# -*- coding: utf-8 -*-
"""meta_model_MNIST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DGJHXDMn2uIO-F4bblglxQIHM4M8WXjz

## Author
This notebook and the underlying implementation were developed by **Halil Candan**  
All external sources used during this project have been properly cited.
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.optim.lr_scheduler import ExponentialLR
import torch.nn.init as init

import torchvision
from torchvision.datasets import MNIST
from torchvision import datasets, transforms
from torch.utils.data import Subset

import matplotlib.pyplot as plt
import numpy as np
import random
from collections import Counter
from functools import reduce
import time
import optuna

"""# Load MNIST Data and Plot Some Random Digits
1. Load the MINST data set.
2. Then plot some of them.

The code for printing the MNIST datasets was inspired by the example at [here](https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial16/Meta_Learning.html).
"""

# Get CPU or GPU device for training
device = "cuda" if torch.cuda.is_available() else "cpu"
device = torch.device(device)
print(f"Using {device} device\n")

# The scaled mean and standard deviation of the MNIST dataset (precalculated)
data_mean = 0.1307
data_std = 0.3081

# Convert input images to tensors and normalize
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((data_mean,), (data_std,))
])

# Augmentation will be applied to train (containing 0-5 digits) set
train_transform = transforms.Compose([
    transforms.RandomRotation(15),
    transforms.ToTensor(),
    transforms.Normalize((data_mean,), (data_std,))
])

# Load MNIST dataset
DATASET_PATH = './mnist_data'
MNIST_data = MNIST(root=DATASET_PATH, train=True, download=True, transform=transform)

augmented_MNIST_data = MNIST(root=DATASET_PATH, train=True, download=True, transform=train_transform)

# Visualize some random MNIST images
NUM_IMAGES = 12
MNIST_images = torch.stack([
    MNIST_data[np.random.randint(len(MNIST_data))][0] for _ in range(NUM_IMAGES)
], dim=0)

# MNIST is grayscale (1 channel), but make_grid expects 3-channel for proper display
# So we'll repeat the channel to make it look like RGB
MNIST_images = MNIST_images.repeat(1, 3, 1, 1)  # (N, 1, H, W) → (N, 3, H, W)

img_grid = torchvision.utils.make_grid(MNIST_images, nrow=6, normalize=True, pad_value=0.9)
img_grid = img_grid.permute(1, 2, 0)

plt.figure(figsize=(8, 8))
plt.title("Image examples from the MNIST dataset")
plt.imshow(img_grid)
plt.axis('off')
plt.show()
plt.close()

"""## Split the MNIST data set into train (contains 0-5 digits) and test (contains 6-9 digits) set

1. Create a list (train_indices) that holds indexes of 0-5 digits.
2. Create a list (test_indices)  that holds indexes of 6-9 digits.
3. Crate MNIST train (contains 0-5 digtis) and MNIST test (contains 6-9) data set.
4. They are called **train_data** and **test_data** respectively.

The link below is CIFAR dataset example. It is converted to MNIST for our case:

https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial16/Meta_Learning.html
"""

train_range = (0, 5)

train_indices = []
test_indices = []

for idx, (_, label) in enumerate(MNIST_data):
    if train_range[0] <= label <= train_range[1]:
        train_indices.append(idx)
    else:
        test_indices.append(idx)

train_data = Subset(augmented_MNIST_data, train_indices) # Contains the 0-5 digits
test_data = Subset(MNIST_data, test_indices) #Contains the 6-9 digits

"""# Define a Class That Creates a Query Set When It is Called
## Class: OneShotMetaDataset
Here is what it does

### Initialization
1. Load MNIST data set (for example 0-5 MNIST set)
2. Groups image indices by class label using a dictionary, so that each key corresponds to a digit (e.g., 0–5), and its value is a list of indices for that class.

### xtr, query = plot_query(query_size) Function
1. Randomly selects a target class `c_tr`.
2. Picks one support sample `x_tr` from `c_tr`.
3. Selects `query_size // 2` positive examples (same class).
4. Selects `query_size // 2` negative examples (different classes).
5. Shuffles positives and negatives to form the query set.
6. Returns support sample (xt) and query samples with binary labels (1 = same class, 0 = different class).
"""

class OneShotMetaDataset:
    def __init__(self, dataset, device=None):
        self.device = device
        self.images = torch.stack([img for img, _ in dataset])
        self.labels = torch.tensor([label for _, label in dataset])

        self.classes = torch.unique(self.labels).tolist()
        self.indices_per_class = {c: torch.where(self.labels == c)[0] for c in self.classes}

    def create_query(self, query_size: int):
        c_tr = random.choice(self.classes)
        class_indices = self.indices_per_class[c_tr]

        perm = torch.randperm(len(class_indices))
        xtr_idx = class_indices[perm[0]].item()
        pos_indices = class_indices[perm[1:1 + query_size // 2]]

        xtr = (self.images[xtr_idx], self.labels[xtr_idx].item())

        neg_class_indices = torch.cat([self.indices_per_class[c] for c in self.classes if c != c_tr])
        perm = torch.randperm(len(neg_class_indices))
        neg_indices = neg_class_indices[perm[:query_size // 2]]

        all_indices = torch.cat([pos_indices, neg_indices])
        perm_all = torch.randperm(len(all_indices))
        shuffled_idx = all_indices[perm_all]

        query = [(self.images[i], lbl.item(), int(lbl.item() == c_tr)) for i, lbl in zip(shuffled_idx, self.labels[shuffled_idx])]

        if self.device is not None:
            xtr = (xtr[0].to(self.device), xtr[1])
            query = [(img.to(self.device), lbl, binary_lbl) for img, lbl, binary_lbl in query]
        return xtr, query

# Helper function for ploting suppor and query list
def plot_support_and_query(x_tr, query):
    x_img, x_label = x_tr

    # Plot x_tr image
    plt.figure(figsize=(14, 3))
    plt.subplot(1, len(query) + 1, 1)
    plt.imshow(x_img.squeeze().cpu(), cmap='gray')
    plt.title(f"Support\nLabel: {x_label}")
    plt.axis('off')

    # Plot query images
    for i in range(len(query)):
        img, true_label, binary_label = query[i]
        plt.subplot(1, len(query) + 1, i + 2)
        plt.imshow(img.squeeze().cpu(), cmap='gray')
        plt.title(f"Label: {true_label}\nY: {binary_label}")
        plt.axis('off')

    plt.tight_layout()
    plt.show()

# Plot some x_tr and query list
seed = 42
random.seed(seed)
np.random.seed(seed)
torch.manual_seed(seed)

torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

obj_train_data    = OneShotMetaDataset(train_data,    device)
obj_test_data     = OneShotMetaDataset(test_data,     device)

x_tr, query = obj_train_data.create_query(query_size=16)
plot_support_and_query(x_tr, query)

"""## Creating Test Queries

A fixed test query list is created once at the beginning for evaluation.

**Why?**
- A fixed test set ensures consistent evaluation across epochs.
- Prevents re-generating new test queries in every epoch, which saves computation time and speeds up training.
- Using a fixed random seed ensures reproducibility of the test set.

"""

# Seed for reproducibility
seed = 42
random.seed(seed)
np.random.seed(seed)
torch.manual_seed(seed)

torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False

test_queries = []
for _ in range(1000):
    (xte_img, xte_lbl), query = obj_test_data.create_query(query_size=16)
    test_queries.append(((xte_img, xte_lbl), query))

#Plot the first suport/query set from the list
x_tr, query = test_queries[0]
plot_support_and_query(x_tr, query)

"""# The Network Architecture
## class Net(nn.Module)
### Initialization
1. Creates the network. Its architecture is showed above.

### sample_weights() Function
1. It passes embedding vector E to the HyperNetwork.
2. Hypernetwork produces weights (θ) of the main network.
3. Main network paramteres are then updated with the new parameters.

### forward() Function
1. It passes images into the main network

### Notes:
* This network codes are inspired by that [torch-hypernetwork-tutorials repo](https://github.com/qu-gg/torch-hypernetwork-tutorials).
* That repo only contains HyperNetwork and Main Network. It lacks feature extractor (CNN) or Glorot initialization. It helped me to understand how hypernetworks are working and give me a base code hence i can develop more complex algorithms.
"""

# Define the architecture of the neural network
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()

        # Feature extraction CNN
        self.feature_net = nn.Sequential(
          nn.Conv2d(1, 32, kernel_size=3, padding=1),   # → 32×28×28
          nn.BatchNorm2d(32),
          nn.ReLU(),
          nn.MaxPool2d(2),                              # → 32×14×14

          nn.Conv2d(32, 64, kernel_size=3, padding=1),  # → 64×14×14
          nn.BatchNorm2d(64),
          nn.ReLU(),
          nn.MaxPool2d(2),                              # → 64×7×7

          nn.Conv2d(64, 128, kernel_size=3, padding=1), # → 128×7×7
          nn.BatchNorm2d(128),
          nn.ReLU(),
          nn.MaxPool2d(2),                              # → 128×3×3

          nn.AdaptiveAvgPool2d(1),                      # → 128×1×1
          nn.Flatten(),                                 # → [B, 128]
          nn.Dropout(0.3)
        )
        feat_dim = 128

        # main-net layer dimensions
        self.layers_dim = [feat_dim, 64, 1]

        # Total main network parameters (weights + biases)
        # Matches hypernetwork output dimension
        self.main_param_cnt  = sum(
            [self.layers_dim[i] * self.layers_dim[i + 1] + self.layers_dim[i + 1]
             for i in range(len(self.layers_dim) - 1)])

        # Initialize embedding vector
        self.embedding = torch.zeros(1, feat_dim)

        # Full hypernetwork, takes embedding input and outputs weights of the main network
        self.hypernet = nn.Sequential(
          nn.Linear(feat_dim, 256), nn.ReLU(), nn.Dropout(0.2),
          nn.Linear(256, 256), nn.ReLU(), nn.Dropout(0.2),
          nn.Linear(256, self.main_param_cnt)
        )
        """
        # Glorot Initialization for HyperNetwork parameters
        for hlayer in self.hypernet:
            if isinstance(hlayer, nn.Linear):
              gain = init.calculate_gain('relu')
              init.xavier_normal_(hlayer.weight, gain=gain)
              if hlayer.bias is not None:
                  nn.init.zeros_(hlayer.bias)
        """

        # Main network structure (dummy initialization)
        # The actual weights will be dynamically generated by the hypernetwork
        self.main_net = nn.Sequential(
            nn.Linear(self.layers_dim[0], self.layers_dim[1]),
            nn.ReLU(),
            nn.Linear(self.layers_dim[1], self.layers_dim[2]),
        )

        # main_net weights should not be updated via backpropagation
        for p in self.main_net.parameters():
            p.requires_grad = False

    # Generates and assigns weights to the main network from the hypernetwork
    def sample_weights(self):
        # Get the main network parameters from the hypernetwork output
        self.hypernet_outputs = self.hypernet(self.embedding)[0]

        # Split and assign generated weights and biases to main_net layers
        next_idx = 0
        for i in range(len(self.layers_dim) - 1):
            in_dim = self.layers_dim[i]
            out_dim = self.layers_dim[i + 1]

            # Extract weight slice and reshape
            cur_idx = next_idx
            next_idx += in_dim * out_dim
            weights_slice = self.hypernet_outputs[cur_idx:next_idx].reshape([out_dim, in_dim])

            # Assign generated weights
            del self.main_net[i * 2].weight
            self.main_net[i * 2].weight = weights_slice

            # Extract bias slice and assign
            cur_idx = next_idx
            next_idx += out_dim
            bias_slice = self.hypernet_outputs[cur_idx:next_idx].reshape(out_dim)
            del self.main_net[i * 2].bias
            self.main_net[i * 2].bias = bias_slice

    def forward(self, x):
        # Extract features from input
        z = self.feature_net(x)

        # Flatten for fully-connected layers
        z = z.view(z.size(0), -1)

        # Predict using dynamically generated main_net
        return self.main_net(z)

"""# def train(model, device, obj_train_data, optimizer, iteration_count, query_size)

## Parameters:

* **model** (Net) — The model

* **device** (torch.device) — The target compute device i.e. "cuda" for GPU or "cpu" for CPU

* **obj_train_data** (OneShotMetaDataset) — OneShotMetaDataset object for creting support-query list

* **optimizer** (torch.optim.Optimizer) — The optimizer for the training

* **iteration_count** (int) — Number of training iterations. Each iteration gathers repeats episodes, aggregates their loss, and performs exactly one optimizer.step().

* **query_size** (int) — NUmbe of query images which are paired with the single support image in every one-shot episode.

<br>

## Training Procedure
In each training episode:

- A **support image** `x_tr` is sampled from digit classes `0–5`.
- A **query set** is created, containing both **positive** (same class) and **negative** (different class) examples.

- The **support image** is passed through the **feature extractor** (`feature_net`) to obtain an embedding.
- This embedding is given to the **hypernetwork**, which generates the parameters `θ` of the binary classifier (`main_net`).

- These parameters are **dynamically assigned** to the classifier (`main_net`), which is then applied to each query embedding.
- The classifier outputs **logits** representing how likely each query image belongs to the **same class as `x_tr`**.

- A **binary cross-entropy loss** is computed using the predicted logits and the ground-truth labels (`1` for same class, `0` for different).
- An optimizer step updates the parameters `γ` of the **hypernetwork** and the **feature extractor**.


## Notes:
- This train codes are inspired by that [torch-hypernetwork-tutorials repo](https://github.com/qu-gg/torch-hypernetwork-tutorials).

# def test(model, device, iteration_count, query_size,  obj_test_data, created_traindata)

## Parameters:

* **model** (Net) — Trained hypernetwork model whose accuracy will be measured.

* **device** (torch.device) — The target compute device i.e. "cuda" for GPU or "cpu" for CPU.

* **iteration_count** (int) — Number of test iterations.

* **query_size** (`int`) — Number of query images paired with the single support
  image in every evaluation episode.

* **obj_test_data** (`OneShotMetaDataset`, *optional*) —  Query generator used at test-time. If provided, the function calls  
  `obj_test_data.create_query(query_size)` on-the-fly for each iterations.

* **created_traindata** (`list`, *optional*) —  A pre-generated list for `(x_tr, query list)` pairs. Used when `obj_test_data` is `None`.


At Each iteration
samples one support image, its query set, updates main network parameters, passes query set and gives model accuracy

<br>

## Testing Procedure
- Each test iteration samples:
  - **One support image** from a randomly chosen test class (6–9)
  - A **query set** consisting of:
    - **8 positive examples** (same class as the support image)
    - **8 negative examples** (randomly chosen from different classes)

- The support image is passed through the `feature_net` and `hypernet` to generate new classifier parameters `θ`
- The `main_net` parameters are updated via `hypernet` parameters `θ`
- The `main_net` is then used to classify new (query) images:  
  It predicts **1** if a query image belongs to the same class (digit) as the support image, and **0** if it belongs to a different class.

- After the iteration loop, compute final accuracy
   ```python
   acc = 100.0 * total_correct / total_queries"
   return acc
   ```


## Notes:
- This train codes are inspired by that [torch-hypernetwork-tutorials repo](https://github.com/qu-gg/torch-hypernetwork-tutorials).
"""

def train(model, device, obj_train_data, optimizer, iteration_count, query_size):
    model.train()

    train_object = obj_train_data
    repeats=1 # M value

    for i in range(iteration_count):

      all_logits = []
      all_labels = []

      for episode in range(repeats):

        # Draw a support example x_tr and a balanced query set Q
        # Half of Q has the same class as x_tr (positives),
        # the other half a different class (negatives)
        (xtr_img, xtr_label), query = train_object.create_query(query_size)

        xtr_img = xtr_img.to(device)

        query_imgs = torch.stack([img for img,_,_ in query]).to(device)
        query_y_label = torch.tensor([b for _,_,b in query], dtype=torch.float32, device=device)

        # x_tr -> CNN -> HyperNet -> Update main net param
        feat = model.feature_net(xtr_img.unsqueeze(0).to(device))
        model.embedding = feat.view(1, -1)
        model.sample_weights() # Update main_net weights using hypernet

        # Forward pass query images
        logits = model(query_imgs).squeeze()
        all_logits.append(logits)
        all_labels.append(query_y_label)

      all_logits = torch.cat(all_logits, dim=0)
      all_labels = torch.cat(all_labels, dim=0)

      # Contruct losss
      loss = F.binary_cross_entropy_with_logits(all_logits, all_labels)

      # Model update for only CNN and HyperNet
      optimizer.zero_grad()
      loss.backward()
      optimizer.step()

def test(model, device, iteration_count, query_size,  obj_test_data=None, created_traindata=None):
    model.eval()

    total_correct = 0
    total_queries = 0

    # Determine which data sapmling source to use: dynamic generator or pre-created list
    if obj_test_data is not None:
        test_object = obj_test_data
    else:
      assert iteration_count <= len(created_traindata), f"iteration_count ({iteration_count}) cannot be greater than the number of available samples ({len(created_traindata)})."

    with torch.no_grad(): # Disable gradient tracking
        for i in range(iteration_count):

          # Sample one test episode: 1 support image + query set
          (xte_img,_), query = test_object.create_query(query_size) if (obj_test_data is not None) else created_traindata[i]

          xte_img = xte_img.to(device)

          query_imgs = torch.stack([img for img,_,_ in query])
          query_imgs = query_imgs.to(device)
          query_y_label = torch.tensor([b for _,_,b in query], dtype=torch.float32, device=device)

          # x_te -> CNN -> HyperNet -> Update main net param
          feat = model.feature_net(xte_img.unsqueeze(0).to(device))
          model.embedding = feat.view(1, -1)
          model.sample_weights() # Update main_net weights using hypernet

          # Forward pass query images through main_net
          logits = model(query_imgs).squeeze()

          # Binary predictions: threshold at 0
          preds  = (logits > 0).float()

          # Update correct prediction count
          total_correct += (preds == query_y_label).sum().item()
          total_queries += query_size

    # Compute final accuracy
    acc = 100. * total_correct / total_queries
    # print(f"\nOne-shot on digits 6–9 over {iteration_count} episodes:" f"  {total_correct}/{total_queries} correct → {acc:.2f}%\n")

    return acc

"""### Final Training Configuration

The hyperparameters shown below were selected using **Optuna hyperparameter optimization**.  
After running a full training loop with these parameters, **it is observed that epoch 2 yields the highest accuracy**  
(**75.16%**).

Therefore, in the final model training, the model is trained only **up to epoch 2** and then evaluated.  
This strategy helps to utilize the most effective training phase and **prevents overfitting** beyond the peak accuracy.

The following code block trains the model up to the best epoch and then performs final testing.

![image.png](data:image/png;base64,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)
"""

# Hyperparameters from Optuna hyperparameter searching
gamma= 0.7211028748038885
opt_name = "Adadelta" # ["Adam", "Adadelta"]
iter_count = 8000

# Dynamic Epoch and Warm- up
MAX_ITERS = 120_000

raw_epochs = round(MAX_ITERS / iter_count)
n_epochs = 3 # max(min(raw_epochs, 50),10)

# Seed for reproductivity
seed = 42
random.seed(seed)
np.random.seed(seed)
torch.manual_seed(seed)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark     = False
torch.use_deterministic_algorithms(False)

# Model, optimizer, scheduler
model = Net().to(device)
opt_params = list(model.feature_net.parameters()) + list(model.hypernet.parameters())

if   opt_name == "Adam":
    lr = 1.51
    optimizer = optim.Adam(opt_params, lr=lr)
elif opt_name == "Adadelta":
    lr = 1.51
    optimizer = optim.Adadelta(opt_params, lr=lr)

scheduler = ExponentialLR(optimizer, gamma=gamma)

best_epoch = 0
best_acc = 0

# Train and Test
for epoch in range(n_epochs):
    train(model, device, obj_train_data,
          optimizer, iteration_count=iter_count, query_size=16)

    val_acc = test(model, device,
                    iteration_count=1000, query_size=16,
                    obj_test_data=obj_test_data)

    if val_acc > best_acc:
        best_epoch = epoch
        best_acc = val_acc

    print(f"epoch: {epoch} - acc: {val_acc:.3f}%")

    scheduler.step()

iteration_count = 100000
val_acc = test(model, device, iteration_count=iteration_count, query_size=16, obj_test_data=obj_test_data)
print(f"Test with iteration_count = {iteration_count} → Accuracy: {val_acc:.2f}%")

"""# The END..
The overal accuracy for our model is 75.07%

#  Optional Sections
---
<br>

The following sections are **optional** and provide two different ways to interact with the model:

#### 1. Running Optuna Hyperparameter Optimization
This section allows the user to run Optuna to automatically find the optimal set of hyperparameters  
(e.g., learning rate, decay factor, number of iterations per epoch).  
It is useful when you want to explore the search space and improve performance systematically.

> ⚠️ Warning: This process may take a long time depending on the number of trials and device used.

#### 2. Manual Training with Custom Hyperparameters
This section allows the user to manually define their own hyperparameters   and train the model accordingly.  
It is useful for running experiments with specific configurations or reproducing a known setup.

You can freely modify values such as:
- `learning_rate`
- `gamma` (learning rate decay factor)
- `iteration_count` (number of one-shot episodes per epoch)
- total `n_epochs`

Both options are fully independent and can be used depending on your needs.

### Optuna Objective Function for Hyperparameter Optimization

The following `objective()` function is used to optimize key training hyperparameters using the **Optuna** framework.  
The goal is to maximize the **test accuracy** of the one-shot learning model on unseen MNIST classes.

#### Search Space:
- `gamma`: Learning rate decay factor for the scheduler (range: 0.70 – 0.99)
- `iter_count`: Number of one-shot episodes per epoch (2000–14000)
- `lr_adadelta`: Learning rate for the **Adadelta** optimizer (0.01–2.0, step=0.005)

#### Dynamic Epoch Calculation:
- The number of epochs is dynamically computed based on a fixed total training effort (`MAX_ITERS = 140,000`)  
  so that each trial trains approximately the same number of samples, regardless of iteration count.

#### Optimization Strategy:
- The `Net()` model is instantiated fresh in every trial and trained with the sampled hyperparameters.
- An `ExponentialLR` scheduler is applied using the trial's `gamma` value.
- After each epoch, the model is evaluated using a fixed test set (`test_queries`) to compute one-shot accuracy.
- The best accuracy seen during training is tracked and used as the **objective value** to be maximized.

#### Early Stopping (Pruning):
- If, after half the epochs, the best accuracy is still below 67%, the trial is reported as underperforming.
- In such cases, **Optuna's pruning mechanism** can terminate the trial early to save computation.

This setup enables a flexible and efficient search over a meaningful hyperparameter space.

<br><br>
This codes are based on the follwing links: <br>
[Mastering Hyperparameter Tuning with Optuna: Boost Your Machine Learning Models!](https://youtu.be/t-INgABWULw?si=AdrwXlFZ-SQ-YevE)

[Master the Power of Optuna: A Step-by-Step Guide](https://medium.com/data-and-beyond/master-the-power-of-optuna-a-step-by-step-guide-ed43500e9b95)
"""

def objective(trial):
    # Hyperparameters
    gamma= trial.suggest_float("gamma", 0.70, 0.99)
    iter_count = trial.suggest_int("iter_count",2000,14000,step=1000)
    lr = trial.suggest_float("lr_adadelta", 0.01, 2.0, step=0.005)

    # Dynamic Epochs
    MAX_ITERS = 140_000
    raw_epochs = round(MAX_ITERS / iter_count)
    n_epochs = max(min(raw_epochs, 50),10)

    # Seed for reproductivity
    seed = 42
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark     = False
    torch.use_deterministic_algorithms(False)

    # Model, optimizer, scheduler
    model = Net().to(device)

    opt_params = list(model.feature_net.parameters()) + list(model.hypernet.parameters())
    optimizer = optim.Adadelta(opt_params, lr=lr)
    scheduler = ExponentialLR(optimizer, gamma=gamma)

    best_acc = 0
    # Test and train
    for epoch in range(n_epochs):
        train(model, device, obj_train_data,
              optimizer, iteration_count=iter_count, query_size=16)

        val_acc = test(model, device, iteration_count=1000, query_size=16, obj_test_data=None, created_traindata=test_queries)

        best_acc = max(best_acc, val_acc)

        if epoch > (n_epochs // 2) and best_acc < 67:
            trial.report(best_acc, step=epoch)
            if trial.should_prune():
                raise optuna.TrialPruned()

        scheduler.step()

    return best_acc           # maximize

# To run the Optuna hyperparameter optimization framework, change `if False:` to `if True:`
if False:
    # Run Optuna to maximize test accuracy by tuning gamma, learning rate, and iteration count
    study = optuna.create_study(direction="maximize")
    study.optimize(objective, n_trials=200, timeout=60*60*3)     # 200 trials or 3 hours

    print("Highest achieved accuracy:", study.best_value)
    print("Optimal hyperparameter configuration:\n", study.best_params)

    # Plot how the best accuracy improved over time
    optuna.visualization.plot_optimization_history(study)

    # Show which hyperparameters had the most influence on performance
    optuna.visualization.plot_param_importances(study)

gamma= 0.7211028748038885
opt_name = "Adadelta" # ["Adam", "Adadelta"]
iter_count = 8000

# Dynamic Epoch and Warm- up
MAX_ITERS = 120_000

raw_epochs = round(MAX_ITERS / iter_count)
n_epochs = max(min(raw_epochs, 50),10)

# Seed for reproductivity
seed = 42
random.seed(seed)
np.random.seed(seed)
torch.manual_seed(seed)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark     = False
torch.use_deterministic_algorithms(False)

# Model, optimizer, scheduler
model = Net().to(device)
opt_params = list(model.feature_net.parameters()) + list(model.hypernet.parameters())

if   opt_name == "Adam":
    lr = 1.51
    optimizer = optim.Adam(opt_params, lr=lr)
elif opt_name == "Adadelta":
    lr = 1.51
    optimizer = optim.Adadelta(opt_params, lr=lr)

scheduler = ExponentialLR(optimizer, gamma=gamma)

best_epoch = 0
best_acc = 0

# Train and Test
for epoch in range(n_epochs):
    train(model, device, obj_train_data,
          optimizer, iteration_count=iter_count, query_size=16)

    val_acc = test(model, device,
                    iteration_count=1000, query_size=16,
                    obj_test_data=obj_test_data)

    if val_acc > best_acc:
        best_epoch = epoch
        best_acc = val_acc

    print(f"epoch: {epoch} - acc: {val_acc:.3f}%")

    scheduler.step()

print(f"{opt_name:9} | lr = {lr:<5.2f} | gamma = {gamma:<5.3f} | iter_count = {iter_count} (for each epoch) | best_epoch = {best_epoch} (acc = {best_acc:.2f}%)")